# Adapting the Game Engine for Dynamic Scenarios

To evolve our game engine to support scenarios that aren't predefined (like those that would be generated by an LLM), we can implement a more flexible architecture. Here's a detailed approach:

## 1. Define a Scenario Provider Behavior

First, we should create a behavior (interface) that all scenario providers must implement:

```elixir
defmodule StartupGame.Engine.ScenarioProvider do
  @moduledoc """
  Behavior that defines the interface for scenario providers.
  Both static and dynamic providers must implement these functions.
  """
  
  @callback get_initial_scenario(GameState.t()) :: Scenario.t()
  @callback get_next_scenario(GameState.t(), String.t()) :: Scenario.t() | nil
  @callback generate_outcome(GameState.t(), Scenario.t(), String.t(), String.t()) :: map()
end
```

## 2. Refactor the Current ScenarioManager

Convert our current `ScenarioManager` to implement this behavior:

```elixir
defmodule StartupGame.Engine.StaticScenarioProvider do
  @moduledoc """
  Provides predefined scenarios from a static collection.
  Implements the ScenarioProvider behavior.
  """
  
  @behaviour StartupGame.Engine.ScenarioProvider
  
  alias StartupGame.Engine.GameState
  alias StartupGame.Engine.Scenario
  
  # Existing scenario definitions...
  
  @impl true
  def get_initial_scenario(_game_state) do
    scenario_id = List.first(@scenario_sequence)
    Map.get(@scenarios, scenario_id)
  end
  
  @impl true
  def get_next_scenario(game_state, current_scenario_id) do
    current_index = Enum.find_index(@scenario_sequence, fn id -> id == current_scenario_id end)
    
    if current_index < length(@scenario_sequence) - 1 do
      next_id = Enum.at(@scenario_sequence, current_index + 1)
      Map.get(@scenarios, next_id)
    else
      nil  # End of game
    end
  end
  
  @impl true
  def generate_outcome(_game_state, scenario, choice_id, _response_text) do
    # Simply return the predefined outcome for this choice
    Map.get(scenario.outcomes, choice_id)
  end
end
```

## 3. Create a Dynamic Scenario Provider

Implement a provider that generates scenarios dynamically, potentially using an LLM:

```elixir
defmodule StartupGame.Engine.DynamicScenarioProvider do
  @moduledoc """
  Provides dynamically generated scenarios, potentially using an LLM.
  Implements the ScenarioProvider behavior.
  """
  
  @behaviour StartupGame.Engine.ScenarioProvider
  
  alias StartupGame.Engine.GameState
  alias StartupGame.Engine.Scenario
  
  @impl true
  def get_initial_scenario(game_state) do
    # Generate an initial scenario based on the startup description
    generate_scenario(game_state, :initial)
  end
  
  @impl true
  def get_next_scenario(game_state, _current_scenario_id) do
    # Check if the game should end
    if should_end_game?(game_state) do
      nil
    else
      # Generate a new scenario based on game history
      generate_scenario(game_state, :next)
    end
  end
  
  @impl true
  def generate_outcome(game_state, scenario, choice_id, response_text) do
    # Generate an outcome based on the player's choice and response text
    # This would likely call an LLM to evaluate the response
    generate_dynamic_outcome(game_state, scenario, choice_id, response_text)
  end
  
  # Private helper functions
  
  defp generate_scenario(game_state, type) do
    # In a real implementation, this would call an LLM
    # For now, we'll use a simple placeholder implementation
    case type do
      :initial ->
        %Scenario{
          id: "dynamic_#{:rand.uniform(1000)}",
          type: :funding,
          situation: "Based on your startup '#{game_state.name}', an angel investor is interested...",
          choices: [
            %{id: "accept", text: "Accept their offer"},
            %{id: "negotiate", text: "Try to negotiate better terms"},
            %{id: "decline", text: "Decline the offer"}
          ],
          outcomes: %{} # Outcomes will be generated dynamically
        }
      :next ->
        # Generate based on game history
        generate_scenario_from_history(game_state)
    end
  end
  
  defp generate_dynamic_outcome(game_state, _scenario, choice_id, response_text) do
    # This would analyze the response text using an LLM and generate an appropriate outcome
    # For now, we'll use a simple placeholder implementation
    case choice_id do
      "accept" ->
        %{
          text: "Your response: '#{String.slice(response_text, 0, 30)}...' led to the investor accepting your terms.",
          cash_change: Decimal.new("100000.00"),
          burn_rate_change: Decimal.new("0.00"),
          ownership_changes: [
            %{entity_name: "Founder", previous_percentage: Decimal.new("100.00"), new_percentage: Decimal.new("85.00")},
            %{entity_name: "Angel Investor", previous_percentage: Decimal.new("0.00"), new_percentage: Decimal.new("15.00")}
          ],
          exit_type: :none
        }
      # Other choices...
    end
  end
  
  defp generate_scenario_from_history(game_state) do
    # Analyze game history to generate an appropriate next scenario
    # This would be a good place to use an LLM
    # ...
  end
  
  defp should_end_game?(game_state) do
    # Logic to determine if the game should end
    # Could be based on number of rounds, financial state, etc.
    length(game_state.rounds) >= 5
  end
end
```

## 4. Modify the Engine to Support Provider Selection

Update the Engine module to accept a scenario provider:

```elixir
defmodule StartupGame.Engine do
  # ...existing code...
  
  @doc """
  Creates a new game with the given startup name, description, and scenario provider.
  """
  @spec new_game(String.t(), String.t(), module()) :: GameState.t()
  def new_game(name, description, provider \\ StartupGame.Engine.StaticScenarioProvider) do
    game_state = GameState.new(name, description)
    
    # Store the provider module in the game state
    game_state = Map.put(game_state, :scenario_provider, provider)
    
    # Get the initial scenario
    initial_scenario = provider.get_initial_scenario(game_state)
    %{game_state | current_scenario: initial_scenario.id, current_scenario_data: initial_scenario}
  end
  
  @doc """
  Processes a player's choice and advances the game state.
  """
  @spec process_choice(GameState.t(), String.t(), String.t()) :: GameState.t()
  def process_choice(game_state, choice_id, response_text \\ "") do
    provider = Map.get(game_state, :scenario_provider)
    scenario = Map.get(game_state, :current_scenario_data)
    
    # Generate outcome based on the choice and response
    outcome = provider.generate_outcome(game_state, scenario, choice_id, response_text)
    
    # Create the round entry
    round = %{
      scenario_id: scenario.id,
      situation: scenario.situation,
      response: response_text || get_choice_text(scenario, choice_id),
      outcome: outcome.text,
      cash_change: outcome.cash_change,
      burn_rate_change: outcome.burn_rate_change,
      ownership_changes: outcome.ownership_changes
    }
    
    # Update game state
    game_state = update_finances(game_state, outcome)
    game_state = update_ownership(game_state, outcome)
    game_state = check_game_end(game_state, outcome)
    
    # Add the round
    game_state = %{game_state | rounds: game_state.rounds ++ [round]}
    
    if game_state.status == :in_progress do
      # Get next scenario
      next_scenario = provider.get_next_scenario(game_state, scenario.id)
      
      if next_scenario do
        %{game_state | 
          current_scenario: next_scenario.id,
          current_scenario_data: next_scenario
        }
      else
        %{game_state | 
          current_scenario: nil,
          current_scenario_data: nil,
          status: :completed
        }
      end
    else
      %{game_state | 
        current_scenario: nil,
        current_scenario_data: nil
      }
    end
  end
  
  # ...rest of the module...
end
```

## 5. Update the GameState Module

Modify the GameState struct to include the scenario provider and current scenario data:

```elixir
defmodule StartupGame.Engine.GameState do
  # ...existing code...
  
  @type t :: %__MODULE__{
    # ...existing fields...
    current_scenario: String.t() | nil,
    current_scenario_data: Scenario.t() | nil,
    scenario_provider: module() | nil
  }
  
  defstruct [
    # ...existing fields...
    current_scenario: nil,
    current_scenario_data: nil,
    scenario_provider: nil
  ]
  
  # ...rest of the module...
end
```

## 6. Create an LLM-Based Provider

When ready to integrate with an actual LLM, you could create a specialized provider:

```elixir
defmodule StartupGame.Engine.LLMScenarioProvider do
  @behaviour StartupGame.Engine.ScenarioProvider
  
  # Implementation that uses an LLM client to generate scenarios and outcomes
  # ...
end
```

## Benefits of This Approach

1. **Modularity**: Clear separation between scenario generation and game logic
2. **Flexibility**: Easy to switch between static and dynamic providers
3. **Testability**: Can test the engine with deterministic providers
4. **Progressive Enhancement**: Start with static scenarios and gradually introduce LLM-generated content
5. **Backward Compatibility**: Existing code can be adapted with minimal changes

## Implementation Strategy

1. Start by defining the behavior and refactoring the existing ScenarioManager
2. Create a simple dynamic provider with placeholder implementations
3. Modify the Engine to support the provider interface
4. Update the GameState to store the provider and scenario data
5. Create tests for both static and dynamic providers
6. When ready, implement the LLM-based provider

This architecture allows for a smooth transition from deterministic to LLM-powered gameplay while maintaining the core game mechanics.