defmodule StartupGame.Engine.LLMScenarioProvider do
  @moduledoc """
  Provides scenarios and outcomes generated by an LLM.
  Implements the ScenarioProvider behavior.

  This module is a placeholder for future implementation that would
  integrate with an actual LLM service.
  """

  @behaviour StartupGame.Engine.ScenarioProvider

  alias StartupGame.Engine.GameState
  alias StartupGame.Engine.Scenario

  @impl true
  @spec get_initial_scenario(GameState.t()) :: Scenario.t()
  def get_initial_scenario(game_state) do
    # In a real implementation, this would call an LLM API
    # with the game state to generate a tailored initial scenario

    # For now, we'll use a placeholder implementation
    scenario_id = "llm_initial_#{:rand.uniform(1000)}"

    # Create the scenario
    scenario = %Scenario{
      id: scenario_id,
      type: :funding,
      situation:
        "Based on your startup '#{game_state.name}' in #{game_state.description}, " <>
          "an investor has approached you with interest in your company. Do you want to:\nA) Accept their offer\nB) Try to negotiate better terms\nC) Decline the offer"
    }

    # Store the choices for this scenario
    choices = [
      %{id: "accept", text: "Accept their offer"},
      %{id: "negotiate", text: "Try to negotiate better terms"},
      %{id: "decline", text: "Decline the offer"}
    ]
    Process.put({__MODULE__, :choices, scenario_id}, choices)

    scenario
  end

  @impl true
  @spec get_next_scenario(GameState.t(), String.t()) :: Scenario.t() | nil
  def get_next_scenario(game_state, _current_scenario_id) do
    # In a real implementation, this would analyze the game history
    # and use an LLM to generate a contextually appropriate next scenario

    # Check if the game should end
    if should_end_game?(game_state) do
      nil
    else
      # For now, we'll use a placeholder implementation
      round_count = length(game_state.rounds)
      scenario_id = "llm_scenario_#{round_count}_#{:rand.uniform(1000)}"

      # Create the scenario
      scenario = %Scenario{
        id: scenario_id,
        type: :other,
        situation:
          "After your previous decision, a new challenge has emerged for #{game_state.name}. Do you want to:\nA) Option A\nB) Option B\nC) Option C"
      }

      # Store the choices for this scenario
      choices = [
        %{id: "option_a", text: "Option A"},
        %{id: "option_b", text: "Option B"},
        %{id: "option_c", text: "Option C"}
      ]
      Process.put({__MODULE__, :choices, scenario_id}, choices)

      scenario
    end
  end

  @impl true
  @spec generate_outcome(GameState.t(), Scenario.t(), String.t()) :: {:ok, Scenario.outcome()} | {:error, String.t()}
  def generate_outcome(_game_state, scenario, response_text) do
    # In a real implementation, this would send the player's response directly to an LLM
    # to generate a contextually appropriate outcome based on the text

    # For this placeholder implementation, we'll try to match the response to a choice first
    case match_response_to_choice(scenario.id, response_text) do
      {:ok, _choice_id} ->
        # Generate a simple outcome based on the choice
        outcome = %{
          text:
            "Based on your response: '#{String.slice(response_text, 0, 30)}...', " <>
              "the outcome is determined. This would be generated by an LLM in a real implementation.",
          cash_change: Decimal.new("10000.00"),
          burn_rate_change: Decimal.new("500.00"),
          ownership_changes: nil,
          exit_type: :none
        }

        {:ok, outcome}

      {:error, reason} ->
        # In a real LLM implementation, we might still generate an outcome even if
        # we can't match to a specific choice, but for now we'll return an error
        {:error, reason}
    end
  end

  # Private helper functions

  @spec should_end_game?(GameState.t()) :: boolean()
  defp should_end_game?(game_state) do
    # Logic to determine if the game should end
    # In a real implementation, this might also consult the LLM

    # For now, end after 7 rounds (longer than the dynamic provider)
    # Or if cash is too low
    # Or if runway is less than 1 month
    length(game_state.rounds) >= 7 or
      Decimal.compare(game_state.cash_on_hand, Decimal.new("0")) == :lt or
      Decimal.compare(GameState.calculate_runway(game_state), Decimal.new("1")) == :lt
  end

  # Helper function to match a response to a choice
  @spec match_response_to_choice(String.t(), String.t()) :: {:ok, String.t()} | {:error, String.t()}
  defp match_response_to_choice(scenario_id, response_text) do
    # Get the choices for this scenario
    choices = get_choices_for_scenario(scenario_id)

    # In a real implementation, this would use an LLM to interpret the response
    # For now, we'll use a simple pattern matching approach

    # Normalize the response text
    normalized = String.trim(response_text) |> String.downcase()

    # Try to match to a choice by:
    # 1. Choice ID
    # 2. Choice text
    # 3. Letter (A, B, C) - assuming choices are presented in order
    choice_with_index = Enum.with_index(choices)

    match = Enum.find(choice_with_index, fn {choice, index} ->
      letter = <<65 + index::utf8>> # A, B, C, etc.

      String.contains?(normalized, String.downcase(choice.id)) ||
      String.contains?(normalized, String.downcase(choice.text)) ||
      String.contains?(normalized, String.downcase(letter))
    end)

    case match do
      {choice, _} -> {:ok, choice.id}
      nil -> {:error, "Could not determine your choice. Please try again with a clearer response."}
    end
  end

  # Helper function to get choices for a scenario
  @spec get_choices_for_scenario(String.t()) :: [map()]
  defp get_choices_for_scenario(scenario_id) do
    Process.get({__MODULE__, :choices, scenario_id}) || []
  end

  # In a real implementation, there would be additional functions for:
  # - Formatting prompts for the LLM
  # - Parsing LLM responses
  # - Error handling and fallbacks
  # - Caching to reduce API calls
  # - etc.
end
